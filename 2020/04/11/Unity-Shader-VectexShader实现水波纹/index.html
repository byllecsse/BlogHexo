<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>用VectexShader实现水波纹 | Bylle</title><link rel="stylesheet" type="text/css" href="/HexoBlog/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/HexoBlog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/HexoBlog/favicon.ico"><link rel="apple-touch-icon" href="/HexoBlog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/HexoBlog/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">用VectexShader实现水波纹</h1><a id="logo" href="/HexoBlog/.">Bylle</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/HexoBlog/."><i class="fa fa-home"> Home</i></a><a href="/HexoBlog/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/HexoBlog/about/"><i class="fa fa-user"> About</i></a><a href="/HexoBlog/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">用VectexShader实现水波纹</h1><div class="post-meta">2020-04-11</div><div class="post-content"><p>顶点动画最常见于规律性的海洋波浪，空中飘舞的旗帜。</p>
<p>有规律可循的变换是计算机程序的强项，程序的计算模拟重复性或者随机性的动画，如波浪、漩涡，在没有其他因素干扰的情况下，他们都会保持一定的系数继续维持当前状态，所以用顶点动画来实现这类动画效果是最方便的，并且使用代码的变换计算对于骨骼或者帧动画来说，性能消耗更小，而且人工实现起来，需要较少的工时。</p>
<p>那么顶点动画是怎么实现的？简单看下unity调用opengl的渲染流程：</p>
<p>unity把模型顶点数据封装起来，由cpu统一发送给gpu，gpu拿到顶点后，在顶点函数中，对每个顶点进行MVP变换后，抛弃被遮挡和屏幕外不可见的顶点，剩下的顶点交由片段函数，进行片元的逐像素处理，最后输入缓冲区，渲染到屏幕。  </p>
<p>所以在顶点函数中，我们可以获取每个顶点的位置、顶点颜色、UV坐标，并且对它们进行修改变换。<br>对于渲染画面而言，并不只是调用渲染管线一次就可以，而是无论画面是否改变，要持续不停地调用，在画面渲染的循环过程中，可以每一帧都改变顶点位置，在一秒的多张画面中，就有了动画效果。</p>
<h3 id="顶点移动"><a href="#顶点移动" class="headerlink" title="顶点移动"></a>顶点移动</h3><p>这是一个z轴方向的动画，有点像蜗牛与地面接触的部分？</p>
<p><img src="z_vertex_wave.png" alt="平面波浪"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(appdata v)</span><br><span class="line">&#123;</span><br><span class="line">	v2f o;</span><br><span class="line">	float4x4 m = &#123;</span><br><span class="line">		float4(sin(v.vertex.z + _Time.y) / 8 + 0.5, 0, 0, 0),</span><br><span class="line">		float4(0, 1, 0, 0),</span><br><span class="line">		float4(0, 0, 1, 0),</span><br><span class="line">		float4(0, 0, 0, 1)</span><br><span class="line">	&#125;;</span><br><span class="line">	v.vertex = mul(m, v.vertex);</span><br><span class="line">	o.vertex = mul(UNITY_MVP_MATRIX, v.vertex);</span><br><span class="line">	o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">	return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GLSL提供了sin等多个三角函数，_Time是Unity shader 提供的内置变量，有几个不同速度的Time.</p>
<blockquote>
<p>_Time    float4    Time (t/20, t, t<em>2, t</em>3), use to animate things inside the shaders.</p>
</blockquote>
<p>除了_Time，unity还提供了_SinTime, _CosTime, unity_DeltaTime等，可以在unity documentation上查到。</p>
<p>在OpenGL中，由于某些原因我们通常使用4×4的变换矩阵，而其中最重要的原因就是大部分的向量都是4分量的。我们能想到的最简单的变换矩阵就是单位矩阵(Identity Matrix)。单位矩阵是一个除了对角线以外都是0的N×N矩阵。 </p>
<blockquote>
<p>(1,0,0,0)<br>(0,1,0,0)<br>(0,0,1,0)<br>(0,0,0,1)</p>
</blockquote>
<p>这在这一段函数中，用每个顶点的z分量计算顶点x值，我们无法使用x分量来计算x，因为在一次计算后，x分量的值已经改变了，z是不会变的分量，同时随着靠近摄像机的远近，线性增减，所以这个动画是向着z轴正方向移动的.将x保存到m矩阵，补齐它在y,z,w的值，这三个值并不需要改变，从乘法角度1*n=n本身，随后m矩阵对v.vertex进行变换乘法，最后是MVP变换。</p>
<h4 id="水波纹"><a href="#水波纹" class="headerlink" title="水波纹"></a>水波纹</h4><p><img src="xy_vertex_wave.png" alt="横向波浪"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 color : COLOR;</span><br><span class="line">    float4 vertex : SV_POSITION;</span><br><span class="line">&#125;;</span><br><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    // A * sin(B * x + c)分别是振幅/频率/偏移</span><br><span class="line">    v.vertex.y = 0.5 * sin(v.vertex.x + _Time.y); </span><br><span class="line">    o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">	float r = v.vertex.y + 0.5;</span><br><span class="line">	o.color = float4(r, r, r, 1);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">float4 frag (v2f i):COLOR</span><br><span class="line">&#123;</span><br><span class="line">    return i.color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次是直接修改v.vertex的y分量，没有再做矩阵乘法，两种都可以，这种更加直接简单点，编程起来更加方便.<br>以v.vertex.x为输入变量，正弦变换后乘以0.5改变的y的上下浮动范围，这个公式是初中数学的，貌似叫正弦公式。为了更加清楚看到每个顶点的高度，我把顶点颜色设置为y的高度值。</p>
<p>由于0.5 * sin(v.vertex.x + _Time.y)的值域是(-0.5, 0.5)，颜色rgb的值域是(0, 1)，所以给y的值整体加上0.5, 将值域调整到(0, 1).  </p>
<p>那在顶点函数里计算的颜色怎么传给片段函数？顶点函数里并不能对顶点进行颜色赋值，所以这就v2f结构体的意义。</p>
<p>struct v2f 从名称上可以看出，vert to frag，意思是从顶点函数传递给片段函数的值的封装结构体。</p>
<p>片段函数需要获取顶点函数中计算好的颜色，就需要写在v2f中，由vert返回v2f，frag的输入参数为v2f，frag的返回值是颜色，COLOR是frag函数返回的语义，GLSL对于内建类型都有语义，这个以后在Vertex Shader中有说到。  </p>
<h4 id="涟漪"><a href="#涟漪" class="headerlink" title="涟漪"></a>涟漪</h4><p><img src="circle_vertex_wave.png" alt="圆形水波"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 向内聚合</span><br><span class="line">v.vertex.y = 0.5 * sin(length(v.vertex.xz) * 2 + _Time.y);</span><br><span class="line"></span><br><span class="line">// 向外扩散</span><br><span class="line">v.vertex.y = 0.5 * sin(-length(v.vertex.xz) * 2 + _Time.y);</span><br></pre></td></tr></table></figure>

<p>从横向波浪变成圆形波浪只需要改变输入变量，由x的值改为x0z平面点到中心位置(0, 0)的距离，所得结果就是点(x.z)到(0, 0)为半径的圆形，产生sin函数曲线的y方向高度变换，这个变换又是随着_Time.y不断增加，在(-0.5, 0.5)范围内周期性变化。</p>
<p>说到这里，三角函数是计算机模拟水波纹的好东西啊，本文中所有的动画都是基于sin()函数的。</p>
<h4 id="斜向水波"><a href="#斜向水波" class="headerlink" title="斜向水波"></a>斜向水波</h4><p><img src="xz_vertex_wave.png" alt="斜向水波"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.vertex.y = 0.2 * sin((v.vertex.x + v.vertex.z) + _Time.y);</span><br></pre></td></tr></table></figure>

<p>斜方向上的波浪，同时取x和z的叠加值作为输入变换，这应该也很好理解，能立刻联想到y = x函数的图示，斜向上45度角，y和x值相等，放到x0z平面就是, x和z值相等的位置进行y高度的计算。</p>
<p>如果不好想象，那就来举个例子：</p>
<ol>
<li>假设sin()的输入值为2，那么有下列点<br> (2, 0) (1.9, 0.1) (1.8, 0.2) (1.7, 0.3) … (0.3, 1.7) (0.2, 1.8) (0.1, 1.9) (2, 0)</li>
<li>这些点在二维坐标系的连线是<br> <img src="vertex_anim_1.png" alt="坐标图示"></li>
<li>当x+z等于相同值时，sin()的结果相同，在该顶点动画里就体现为相同高度，而sin()是周期性的曲线，就形成了一定频率的斜向波浪。  </li>
</ol>
<h4 id="更真实的波浪"><a href="#更真实的波浪" class="headerlink" title="更真实的波浪"></a>更真实的波浪</h4><p><img src="xy_vertex_wave_2.png" alt="更加真实的波浪">  </p>
<p>将两个正弦波相加，让振幅/频率/偏移各不相同，来达到水波纹的此起彼伏效果.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.vertex.y += 0.2 * sin((v.vertex.x + v.vertex.z) + _Time.y);</span><br><span class="line">v.vertex.y += 0.3 * sin((v.vertex.x - v.vertex.z) + _Time.w);</span><br></pre></td></tr></table></figure>

<h3 id="顶点旋转"><a href="#顶点旋转" class="headerlink" title="顶点旋转"></a>顶点旋转</h3><p>顶点的移动是改变顶点分量的值，不管是直接加减一个常量，还是赋值一个三角函数计算出来的变量。那旋转呢？旋转必须经矩阵乘法，而且这个矩阵的量和角度相关。</p>
<p>绕x轴旋转<br><img src="x_rotate_matrix.png" alt="x旋转矩阵"></p>
<p>绕y轴旋转<br><img src="y_rotate_matrix.png" alt="y旋转矩阵"></p>
<p>绕z轴旋转<br><img src="z_rotate_matrix.png" alt="z旋转矩阵"></p>
<p>这些矩阵怎么得到的，<a href="http://www.cnblogs.com/graphics/archive/2012/08/08/2609005.html" target="_blank" rel="noopener">这里</a>有推导。</p>
<p>下图这个“风车”动画会正向逆向交替转动。</p>
<p><img src="rotate_vertex_anim.png" alt="顶点动画“风车”"></p>
<p>将所有顶点围绕y轴旋转angle度，然后要让这个角度不断随着时间变换，unity提供了_SinTime，这个随着时间变化的正弦值，它的类型是fixed4，x/y/z/w的值分别是(t/8, t/4, t/2, t)，由于每个顶点的围绕y轴旋转角度相同，就会造成越靠近中心的顶点，转速越快，越远离中心的顶点，转速越慢，从而形成一种拖尾的效果。</p>
<p>下列代码中是围绕y轴的顶点选择变换。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata_base v)</span><br><span class="line">&#123;</span><br><span class="line">	v2f o;</span><br><span class="line">	fixed angle = length(v.vertex) * _SinTime.w;</span><br><span class="line">	fixed4x4 m = &#123;</span><br><span class="line">		fixed4(cos(angle), 0, sin(angle), 0),</span><br><span class="line">		fixed4(0, 1, 0, 0),</span><br><span class="line">		fixed4(-sin(angle), 0, cos(angle), 0),</span><br><span class="line">		fixed4(0, 0, 0, 1)</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	v.vertex = mul(m, v.vertex);</span><br><span class="line">	o.vertex = UnityObjectToClipPos(v.vertex); // - 1</span><br><span class="line"></span><br><span class="line">	return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1位置有个新的内建函数UnityObjectToClipPos，可以在内置的UnityCG.cginc中找到，它的返回值和参数是：<br>float4 UnityObjectToClipPos(float3 pos)</p>
<p>手册中的描述：<br>Transforms a point from object space to the camera’s clip space in homogeneous coordinates. This is the equivalent of mul(UNITY_MATRIX_MVP, float4(pos, 1.0)), and should be used in its place.</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在顶点函数中，顶点的位置可以任意通过矩阵变换得到，变换后的顶点位置再做一次MVP变换，得到摄像机所见的图像。</p>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/HexoBlog/2020/04/11/Unity-Shader-简单SurfaceShader分析/">一个简单SurfaceShader的分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/04/11/Unity-Shader-VectexShader实现水波纹/">用VectexShader实现水波纹</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/04/11/Unity-Shader-简单SurfaceShader分析/">一个简单SurfaceShader的分析</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/04/11/Unity-降低DrawCall的手段/">降低DrawCall的手段</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/04/10/Unity-浅谈衣柜系统/">浅谈衣柜系统</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/04/10/Lua-Class的实现/">Lua class  实现</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/04/10/Unity-Shader-模板测试/">Unity 模板测试</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/02/23/xLua-热更新实现原理/">xLua热更新实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/02/20/Lua-Table的内部实现/">Lua table的内部实现</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/02/19/Lua-与C#交互/">CSharp-Lua-交互</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/02/18/Unity-AssetBundle基础/">AssetBundle基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/HexoBlog/." rel="nofollow">Bylle.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/HexoBlog/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/HexoBlog/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/HexoBlog/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/HexoBlog/js/smartresize.js?v=0.0.0"></script></div></body></html>