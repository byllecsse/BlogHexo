<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>CSharp-Lua-交互 | Bylle</title><link rel="stylesheet" type="text/css" href="/HexoBlog/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/HexoBlog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/HexoBlog/favicon.ico"><link rel="apple-touch-icon" href="/HexoBlog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/HexoBlog/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CSharp-Lua-交互</h1><a id="logo" href="/HexoBlog/.">Bylle</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/HexoBlog/."><i class="fa fa-home"> Home</i></a><a href="/HexoBlog/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/HexoBlog/about/"><i class="fa fa-user"> About</i></a><a href="/HexoBlog/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CSharp-Lua-交互</h1><div class="post-meta">2020-02-19</div><div class="post-content"><h2 id="普通C-调用lua"><a href="#普通C-调用lua" class="headerlink" title="普通C#调用lua"></a>普通C#调用lua</h2><p>需要先下载<a href="http://files.luaforge.net/releases/luainterface/luainterface" target="_blank" rel="noopener">lua支持类库</a>将LuaInterface.dll &amp; luaxx.dll(xx是lua版本)引用到项目中。</p>
<p>步骤：</p>
<ol>
<li>申明lua虚拟机：Lua m_lua = new Lua();</li>
<li>将C#对象方法注册到lua中，是lua可以调用该方法：m_lua.RegisterFunction(“MethorName”, class, class.GetType().GetMethod(“MethodName”));</li>
<li>加载lua代码：m_lua.DoFild(“lua_file.lua”);</li>
<li>调用lua方法: Object[] objs = m_lua.GetFunction(“MethodName”).Call(args);</li>
</ol>
<br>

<h2 id="使用xLua进行C-与Lua交互"><a href="#使用xLua进行C-与Lua交互" class="headerlink" title="使用xLua进行C#与Lua交互"></a>使用xLua进行C#与Lua交互</h2><p>拿最简单的先举例：<br>在C#中生成一个对象 GameObject go = new GameObject();<br>用Lua代码写则是 local go = CS.UnityEngin.GameObject()</p>
<p>在Lua中没有new关键字，新建对象时直接省略new，所有C#相关都加上”CS.”前缀，包括构造函数、静态成员属性&amp;方法，并且跟上命名空间namespace，new GameObject的命名空间是UnityEngine，所以在Lua中就是CS.UnityEngine.GameObject.</p>
<blockquote>
<p>xLua也支持多个构造函数：local go = CS.UnityEngine.GameObject(‘helloLua’)</p>
</blockquote>
<p>为了避免每次使用某个Unity类型都去做一次寻址操作，一般会在lua文件头用个局部变量做缓存，注意lua文件和函数内local的生命周期.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> GameObject = CS.UnityEngine.GameObject</span><br><span class="line">GameObject.Find(<span class="string">'helloworld'</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>xLua能支持一些参数个数，number、string、array类型区分的重载，但C#终得int、float、double都对应lua的number，若C#有这些类型的重载，Lua则无法区分开来，只能调用到其中的一个（生成代码中排前面的那个）。</li>
<li>支持枚举类型的访问，如果加入到生成代码的话（即添加[LuaCallCSharp]标签），枚举类将支持__CastFrom方法，可以实现从一个整数或者字符串到枚举值的转换。</li>
</ol>
<h3 id="在Unity中Component调用lua"><a href="#在Unity中Component调用lua" class="headerlink" title="在Unity中Component调用lua"></a>在Unity中Component调用lua</h3><p>我拿xLua的框架来分析下C#和Lua在Unity游戏内的交互，xLua为构建LuaTable、lua获取Unity组件内容和C#代码变量做了很多事情，简化了很多Lua调用Unity组件的操作，当然xLua的优势在于热更新，而且提出的热更新方案比较先进，虽然后面xLua的创建者自己又写了个iFix，貌似可以更新C#…好厉害..</p>
<p>简单分析下xLua的交互使用，详细的xLua热更新我要再写一篇记录。</p>
<p>XLuaManager的构造函数内启动lua虚拟机调用LuaEnv，执行init_xlua lua代码进行了一些类与元表配置，<font color="red">(详细以后再看Q.Q)</font>，一系列操作后，在lua可以直接通过CS来访问C#的各项类与组件，比如组件统一在UnityEngine命名空间下，就可以通过CS.UnityEngine来访问。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> UnityEngine = CS.UnityEngine;</span><br><span class="line">UnityEngine.Transform</span><br><span class="line">UnityEngine.UI.Button</span><br></pre></td></tr></table></figure>

<p>UnityEngine下的各项组件已经由xLua关联好了，并且获取到实例后，可以使用UnityEngine的所有方法，超级方便。<br>比如我调用tranform的Button组件，或者为gameObject添加一个组件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m_actionText = this.transform:Find(<span class="string">"ActionText"</span>):GetComponent(<span class="string">"Text"</span>);</span><br><span class="line">m_actionItem = this.transform:Find(<span class="string">"ItemPanel/ActionItem"</span>):AddComponent(<span class="string">"Image"</span>);</span><br></pre></td></tr></table></figure>

<p>这样一来我只要定义好lua组件的文件头，方法内获取Unity或者是C#的函数都通过CS这个封装，像C#调用一样使用就可以，减少了很多编码和学习成本，文件头指的是lua表的创建，xLua获取文件信息都是将文件映射到lua table，变量和方法都会是这个table的参数，所以C#调用lua将会以table参数的形式调用。对于LuaTable，方法的类型是Action，调用方法是Get<action>(funcName)。</action></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Action func = luaTable.Get&lt;Action&gt;(funcName);</span><br><span class="line">if(func != null) &#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="LuaComponentLoader-加载lua组件"><a href="#LuaComponentLoader-加载lua组件" class="headerlink" title="LuaComponentLoader 加载lua组件"></a>LuaComponentLoader 加载lua组件</h3><p>该类继承自MonoBehaviour，必须挂在某个控件上，它没有做热更新或者C#代码替换，所以需要执行lua component是要停用lua Component 的C#版本，也就是说它单纯是个lua版的组件，用于执行原C# component的功能。</p>
<p>如果用 lua 模拟C#代码，必须在lua脚本中定义和C# MonoBehaviour相同的生命周期函数，至于函数名可以不一样，随LuaComponentLoader中的调用代码而定，但一般来说需要Awake、Start、Update。</p>
<p>其实LuaComponentLoad也没有什么特别高深的东西，它是以LuaTable的形式获取了lua脚本的各项参数，并在自己的MonoBehaviour生命周期中调用lua相应的生命周期函数，比如LuaComponentLoad中的Awake调用Lua中的Awake.</p>
<blockquote>
<p>为了让代码简短些，我省略了一些值的判断。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LuaComponentLoader : MonoBehaviour &#123;</span><br><span class="line">    public string luaComponentName;</span><br><span class="line">    public bool Load() &#123;</span><br><span class="line">        luaTable = XLuaManager.instance.GetLuaTable(luaComponentName);  // 需要判断string.IsNullOrEmpty</span><br><span class="line">        luaTable.Set&lt;string, Transform&gt;(&quot;transform&quot;, transform);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void CallLuaFunction(string funcName) &#123;</span><br><span class="line">        Action func = luaTable.Get&lt;Action&gt;(funcName);</span><br><span class="line">        func(); // 需要判断func != null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Awake() &#123;</span><br><span class="line">        if (Load())</span><br><span class="line">            CallLuaFunction(&quot;Awake&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="访问自定义类成员属性、方法"><a href="#访问自定义类成员属性、方法" class="headerlink" title="访问自定义类成员属性、方法"></a>访问自定义类成员属性、方法</h3><p>和C#访问自身类一样，访问成员属性方法的时候，需要通过类的实例去访问。<br>假设定义如下类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace MyExamples &#123;</span><br><span class="line">    [LuaCallCSharp]</span><br><span class="line">    public class Test &#123;</span><br><span class="line">        public int index;</span><br><span class="line">        public int Add(int a, int b) &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lua Call C#代码的时候，C#处生成的代码基本都需要打标签[LuaCallCSharp]。</p>
<p>对于[LuaCallCSharp]标签的解释，参考xLua的Github FAQ:</p>
<p>一个C#类型加了这个配置，xLua会生成这个类型的适配代码（包括构造该类型实例，访问其成员属性、方法，静态属性、方法），否则将会尝试用性能较低的反射方式来访问。一个类型的扩展方法（Extension Methods）加了这配置，也会生成适配代码并追加到被扩展类型的成员方法上。xLua只会生成加了该配置的类型，不会自动生成其父类的适配代码，当访问子类对象的父类方法，如果该父类加了LuaCallCSharp配置，则执行父类的适配代码，否则会尝试用反射来访问。反射访问除了性能不佳之外，在il2cpp下还有可能因为代码剪裁而导致无法访问，后者可以通过下面介绍的ReflectionUse标签来避免。</p>
<p>对应lua代码的访问：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Test = CS.MyExamples.Test</span><br><span class="line"><span class="keyword">local</span> test = Test()</span><br><span class="line">test.index = <span class="number">66</span></span><br><span class="line"><span class="built_in">print</span>(test.index, test.Add(test, <span class="number">1</span>, <span class="number">2</span>), test:Add(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：一般用’:’访问成员函数（冒号语法糖），如果是’.’访问则需要第一个参数传递该对象。</p>
</blockquote>
<h4 id="输入输出属性out-ref"><a href="#输入输出属性out-ref" class="headerlink" title="输入输出属性out, ref"></a>输入输出属性out, ref</h4><p>C#有两个特殊关键字out、ref，使得定义该关键字的参数不用经过函数返回值return，lua对此的处理是统一当作返回值处理（反正lua可以返回多个值）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// c#</span><br><span class="line">public class A &#123;</span><br><span class="line">    public static int Method(int a, ref int b, out int c, Action funA, out Action funB)  &#123;</span><br><span class="line">        c = 10;</span><br><span class="line">        funA();</span><br><span class="line">        funB() =&gt; &#123; Debug.Log(&quot;funB&quot;); &#125;</span><br><span class="line">        return 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-- lua</span><br><span class="line">local ret, ret_b, ret_c, ret_funB = CS.MyExamples.A.Method(1, 2, function()</span><br><span class="line">    print(&quot;funA&quot;)</span><br><span class="line">end)</span><br><span class="line">ret_funB()</span><br></pre></td></tr></table></figure>

<p>funB在C#函数内用了lamaba表达式重新定义了匿名方法，return返回值是函数多返回值的第一个，如果return多个值也会按照顺序优先排列，随后根据ref和out的参数顺序返回，暂时还没有查到lua多重返回最多可以返回多少个值。</p>
<p>将lua的function传递到了C# Action参数中，等于上一篇说讲到的lua函数映射到C#委托，因此我们需要将Action添加到CSharpCallLua白名单中。类似的还有Func&lt;&gt;等委托（否则将会报错LuaException: c# exception:System.InvalidCastException: This type must add to CSharpCallLua: System.Action）</p>
<br>

<h3 id="事件类型的使用"><a href="#事件类型的使用" class="headerlink" title="事件类型的使用"></a>事件类型的使用</h3><h4 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h4><p>调用C# delegate就像和调用普通lua函数一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[LuaCallCSharp]</span><br><span class="line">public class TestSon : Test &#123;</span><br><span class="line">    public delegate int IntDelegate(int a);</span><br><span class="line">    public IntDelegate intDelegate = (a) =&gt; &#123;</span><br><span class="line">        Debug.Log(&quot;C# -- intDelegate --a = &quot; + a);</span><br><span class="line">        return a;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-- lua访问</span><br><span class="line">testSon.intDelegate(10);</span><br></pre></td></tr></table></figure>

<p>+操作符：对应C#的+操作符，把两个调用串成一个调用链，右操作数可以是同类型的C# delegate或者lua函数。<br>-操作符：和+相反，把一个delegate从调用链中移除。</p>
<blockquote>
<p>delegate属性可以用一个lua function来赋值。</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">lua_delegate</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'lua_delegate :'</span>, a)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">testSon.intDelegate = lua_delegate + testSon.intDelegate <span class="comment">--combine，这里演示的是C#delegate作为右值，左值也支持</span></span><br><span class="line">testSon.intDelegate(<span class="number">100</span>)</span><br><span class="line">testSon.intDelegate = testSon.intDelegate - lua_delegate <span class="comment">--remove</span></span><br><span class="line">testSon.intDelegate(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>比如定义如下event，从定义intEvent的地方可以看出，intEvent是委托IntDelegate的对象，一个主要的区别是委托是类型，而事件是委托的对象，event只能写在’+’’-‘的左侧，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TestSon : Test &#123;</span><br><span class="line">    public event IntDelegate intEvent;</span><br><span class="line"></span><br><span class="line">    public void ExeEvent(int a) &#123;</span><br><span class="line">        intEvent(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在lua内对事件对象进行访问，并添加/移除其委托的函数方法，在C#方法中执行这个事件。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">lua_eventCallback1</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'lua_eventCallback1 :'</span>, a)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">lua_eventCallback2</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'lua_eventCallback2 :'</span>, a)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--增加事件回调</span></span><br><span class="line">testSon:intEvent(<span class="string">'+'</span>, lua_eventCallback1);</span><br><span class="line">testSon:intEvent(<span class="string">'+'</span>, lua_eventCallback2);</span><br><span class="line">testSon:ExeEvent(<span class="number">100</span>);</span><br><span class="line"><span class="comment">--移除事件回调</span></span><br><span class="line">testSon:intEvent(<span class="string">'-'</span>, lua_eventCallback1);</span><br><span class="line">testSon:ExeEvent(<span class="number">1000</span>);</span><br><span class="line">testSon:intEvent(<span class="string">'-'</span>, lua_eventCallback2)</span><br></pre></td></tr></table></figure>

<p>这里又可以扯一下<strong>C#委托与事件</strong>的区别：<br>委托是一个类，该类内部维护着一个字段，指向一个方法。<br>事件可以被看作一个委托类型的变量，通过事件注册、取消多个委托或方法。</p>
<p>举几个代码例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 通过委托执行方法</span><br><span class="line">class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Example example = new Example();</span><br><span class="line">            example.Go();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Example</span><br><span class="line">    &#123;</span><br><span class="line">        public delegate void DoSth(string str);</span><br><span class="line">        internal void Go()</span><br><span class="line">        &#123;</span><br><span class="line">            //声明一个委托变量，并把已知方法作为其构造函数的参数</span><br><span class="line">            DoSth d = new DoSth(Print);</span><br><span class="line">            string str = &quot;Hello,World&quot;;</span><br><span class="line">            //通过委托的静态方法Invoke触发委托</span><br><span class="line">            d.Invoke(str);</span><br><span class="line">        &#125;</span><br><span class="line">        void Print(string str)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在CLR运行时，委托DoSth实际上就一个类，该类有一个参数类型为方法的构造函数，并且提供了一个Invoke实例方法，用来触发委托的执行。</li>
<li>委托DoSth定义了方法的参数和返回类型</li>
<li>通过委托DoSth的构造函数，可以把符合定义的方法赋值给委托</li>
<li>调用委托的实例方法Invoke执行了方法</li>
</ul>
<p>当我们定义委托的时候：<br>public delegate void GreetingDelegate(string name);</p>
<p>编译器会生成下面这一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public sealed class GreetingDelegate:System.MulticastDelegate&#123;</span><br><span class="line">   public GreetingDelegate(object @object, IntPtr method);</span><br><span class="line">   public virtual IAsyncResult BeginInvoke(string name, AsyncCallback callback, object @object);</span><br><span class="line">   public virtual void EndInvoke(IAsyncResult result);</span><br><span class="line">   public virtual void Invoke(string name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 通过事件执行方法</span><br><span class="line"> public class Example</span><br><span class="line">    &#123;</span><br><span class="line">        public delegate void DoSth(object sender, EventArgs e);</span><br><span class="line">        public event DoSth myDoSth;</span><br><span class="line">        internal void Go()</span><br><span class="line">        &#123;</span><br><span class="line">            //声明一个委托变量，并把已知方法作为其构造函数的参数</span><br><span class="line">            DoSth d = new DoSth(Print);</span><br><span class="line">            object sender = 10;</span><br><span class="line">            EventArgs e = new EventArgs();</span><br><span class="line">            myDoSth += new DoSth(d);</span><br><span class="line">            myDoSth(sender, e);</span><br><span class="line">        &#125;</span><br><span class="line">        void Print(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(sender);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>声明了事件myDoSth,事件的类型是DoSth这个委托</li>
<li>通过+=为事件注册委托</li>
<li>通过DoSth委托的构造函数为事件注册委托实例</li>
<li>采用委托变量(参数列表)这种形式，让事件执行方法</li>
</ul>
<p>稍微总结下：</p>
<ol>
<li>委托可以理解为指向函数的指针；</li>
<li>委托是类型，事件是对象；</li>
<li>事件是一个private的委托，只能执行add、remove方法。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/wangjiangrong/article/details/79784785" target="_blank" rel="noopener">https://blog.csdn.net/wangjiangrong/article/details/79784785</a><br><a href="https://www.cnblogs.com/darrenji/p/3967381.html" target="_blank" rel="noopener">https://www.cnblogs.com/darrenji/p/3967381.html</a></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/HexoBlog/2020/02/20/Lua-Table的内部实现/">Lua table的内部实现</a><a class="next" href="/HexoBlog/2020/02/18/Unity-AssetBundle基础/">AssetBundle基础</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/04/11/Unity-Shader-VectexShader实现水波纹/">用VectexShader实现水波纹</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/04/11/Unity-Shader-简单SurfaceShader分析/">一个简单SurfaceShader的分析</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/04/11/Unity-降低DrawCall的手段/">降低DrawCall的手段</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/04/10/Unity-浅谈衣柜系统/">浅谈衣柜系统</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/04/10/Lua-Class的实现/">Lua class  实现</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/04/10/Unity-Shader-模板测试/">Unity 模板测试</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/02/23/xLua-热更新实现原理/">xLua热更新实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/02/20/Lua-Table的内部实现/">Lua table的内部实现</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/02/19/Lua-与C#交互/">CSharp-Lua-交互</a></li><li class="post-list-item"><a class="post-list-link" href="/HexoBlog/2020/02/18/Unity-AssetBundle基础/">AssetBundle基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/HexoBlog/." rel="nofollow">Bylle.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/HexoBlog/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/HexoBlog/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/HexoBlog/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/HexoBlog/js/smartresize.js?v=0.0.0"></script></div></body></html>